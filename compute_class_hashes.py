#!/usr/bin/env python3
"""
Script to compute SHA256 hashes of each class in shared_types.py
and set variables for those hashes.
"""

import ast
import hashlib
from pathlib import Path
from typing import List

import click
from pydantic import BaseModel


def extract_class_source(file_path: str, class_name: str) -> str:
    """Extract the source code of a specific class from a Python file."""
    with open(file_path, "r", encoding="utf-8") as f:
        content = f.read()

    # Parse the AST
    tree = ast.parse(content)

    # Find the class definition
    for node in ast.walk(tree):
        if isinstance(node, ast.ClassDef) and node.name == class_name:
            lines = content.splitlines()
            start_line = node.lineno - 1  # Convert to 0-based indexing

            # Find the end of the class by looking for the next class or end of file
            end_line = len(lines)

            # Look for the next class or function at the same indentation level
            for next_node in ast.walk(tree):
                if (
                    isinstance(next_node, (ast.ClassDef, ast.FunctionDef))
                    and next_node.lineno > node.lineno
                    and next_node.col_offset == node.col_offset
                ):
                    end_line = next_node.lineno - 1
                    break

            # Extract the class source
            class_lines = lines[start_line:end_line]

            # Remove trailing empty lines
            while class_lines and not class_lines[-1].strip():
                class_lines.pop()

            return "\n".join(class_lines)

    raise ValueError(f"Class '{class_name}' not found in {file_path}")


def compute_sha256(text: str) -> str:
    """Compute SHA256 hash of the given text."""
    return hashlib.sha256(text.encode("utf-8")).hexdigest()


def get_all_classes_from_file(file_path: str) -> List[str]:
    """Extract all class names from a Python file."""
    with open(file_path, "r", encoding="utf-8") as f:
        content = f.read()

    tree = ast.parse(content)
    classes = []

    for node in ast.walk(tree):
        if isinstance(node, ast.ClassDef):
            classes.append(node.name)

    return sorted(classes)


class ClassItem(BaseModel):
    source_path: Path
    items: list[str]


@click.command()
def main() -> None:
    """Main function to compute class hashes and set variables."""
    source_paths = [
        Path("inky-mbta-tracker/shared_types/shared_types.py"),
        Path("inky-mbta-tracker/mbta_responses.py"),
    ]

    for source_path in source_paths:
        if not source_path.exists():
            print(f"Error: {source_path} not found!")
            return

    classes: list[ClassItem] = []
    # Get all classes from the file
    for source_path in source_paths:
        classes.append(
            ClassItem(
                source_path=source_path,
                items=get_all_classes_from_file(str(source_path)),
            )
        )

    class_hashes: dict[str, str] = {}

    for item in classes:
        for class_name in item.items:
            class_source = extract_class_source(str(item.source_path), class_name)
            class_hash = compute_sha256(class_source)
            class_hashes[class_name] = class_hash
            print(f"\n{class_name}:")
        print(f"  Hash: {class_hash}")
        print(f"  Source preview: {class_source[:100]}...")

    # Set variables for each class hash
    print("\n" + "=" * 80)
    print("CLASS HASH VARIABLES")
    print("=" * 80)

    for class_name, class_hash in sorted(class_hashes.items()):
        variable_name = f"{class_name.upper()}_HASH"
        print(f'{variable_name} = "{class_hash}"')

    # Also create a dictionary with all hashes
    print("\nCLASS_HASHES = {")
    for class_name, class_hash in sorted(class_hashes.items()):
        print(f'    "{class_name}": "{class_hash}",')
    print("}")

    # Save hashes to a file
    output_file = Path("./inky-mbta-tracker/shared_types/class_hashes.py")
    with open(output_file, "w", encoding="utf-8") as f:
        f.write("# Auto-generated class hashes from shared_types.py\n")
        f.write("# Generated by compute_class_hashes.py\n\n")

        for class_name, class_hash in sorted(class_hashes.items()):
            variable_name = f"{class_name.upper()}_HASH"
            f.write(f'{variable_name} = "{class_hash}"\n')

        f.write("\nCLASS_HASHES = {\n")
        for class_name, class_hash in sorted(class_hashes.items()):
            f.write(f'    "{class_name}": "{class_hash}",\n')
        f.write("}\n")

    print(f"\nClass hashes saved to {output_file}")


if __name__ == "__main__":
    main()
